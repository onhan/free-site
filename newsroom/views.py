import datetime
import logging

from blocks.models import Group
from bs4 import BeautifulSoup
from django.contrib import messages
from django.contrib.admin.views.decorators import staff_member_required
from django.contrib.sites.models import Site
from django.core.paginator import EmptyPage, PageNotAnInteger, Paginator
from django.db.models import Q
from django.http import (Http404, HttpResponseForbidden, HttpResponseRedirect,
                         JsonResponse)
from django.shortcuts import get_object_or_404, redirect, render
from django.urls import reverse
from django.utils import timezone
from django.utils.html import strip_tags
from django.views import generic
from django.views.decorators.http import last_modified
from django.views.generic import View
from letters.models import Letter
from letters.settings import DAYS_AGO
from pgsearch.utils import searchPostgresDB, searchArticlesAndPhotos
from django.conf import settings as django_settings

from . import models, settings, utils
from .forms import ArticleForm, ArticleListForm, AdvancedSearchForm

logger = logging.getLogger(__name__)


def get_blocks(group_name="Home"):
    try:
        return Group.objects.get(name=group_name).get_blocks()
    except:
        return []


def get_blocks_in_context(context, group_name="Home", context_key="blocks"):
    context[context_key] = get_blocks(group_name)
    return context


class ArticleList(generic.ListView):
    context_object_name = 'article_list'
    template_name = "newsroom/article_list.html"
    paginate_by = settings.ARTICLES_PER_PAGE

    def get_queryset(self):
        return models.Article.objects.list_view()

    def get_context_data(self, **kwargs):
        context = super(ArticleList, self).get_context_data(**kwargs)
        #  context = get_blocks_in_context(context)
        context['most_popular_html'] = \
            models.MostPopular.get_most_popular_html()
        date_from = timezone.now() - datetime.timedelta(days=DAYS_AGO)
        context['letters'] = Letter.objects.published().\
            filter(published__gte=date_from).order_by('-published')
        return context


def last_article_modified(request):
    return models.Article.objects.published().latest("modified").modified


class HomePage(ArticleList):
    template_name = "newsroom/home.html"

    def get_context_data(self, **kwargs):
        context = super(HomePage, self).get_context_data(**kwargs)
        context = get_blocks_in_context(context, "Home_Top", "topblocks")
        return context

    # LEAVE THIS COMMENTED OUT CODE IN CASE OF EMERGENCY IN
    # WHICH CODE NEEDS TO CHANGE URGENTLY.

    # def get(self, request, *args, **kwargs):
    # Add messages here. E.g.
    #    messages.add_message(request, messages.INFO,
    #                     "We're only publishing urgent "
    #                     "news until 7 January. Have a "
    #                     "safe holiday season.")
    #    request = super(HomePage, self).get(request, args, kwargs)
    #    return request


home_page_view = HomePage.as_view()
home_page_view = last_modified(last_article_modified)(home_page_view)


class OpinionAnalysisList(ArticleList):

    def get_queryset(self):
        return models.Article.objects.list_view().filter(
            Q(category__name="Opinion") |
            Q(category__name="Analysis"))

    def get_context_data(self, **kwargs):
        context = super(OpinionAnalysisList, self).get_context_data(**kwargs)
        context['heading'] = "Opinion and Analysis"
        return context


class AuthorList(generic.ListView):
    model = models.Author

class AuthorDetail(ArticleList):

    def get_queryset(self):
        self.author = get_object_or_404(models.Author, pk=self.args[0])
        return models.Article.objects.list_view().filter(
            Q(author_01=self.author) | Q(author_02=self.author) |
            Q(author_03=self.author) | Q(author_04=self.author) |
            Q(author_05=self.author) |
            Q(cached_byline_no_links__icontains=str(self.author)))

    def get_context_data(self, **kwargs):
        context = super(AuthorDetail, self).get_context_data(**kwargs)
        context['heading'] = "Articles by " + str(self.author)
        context['image'] = self.author.photo
        context['description'] = self.author.description
        return context


class CategoryList(generic.ListView):
    model = models.Category


class CategoryDetail(ArticleList):

    def get_queryset(self):
        self.category = get_object_or_404(models.Category,
                                          name__iexact=self.args[0])
        return models.Article.objects.list_view(). \
            filter(category=self.category)

    def get_context_data(self, **kwargs):
        context = super(CategoryDetail, self).get_context_data(**kwargs)
        context['heading'] = self.category.name
        return context


class RegionList(generic.ListView):
    model = models.Region


class RegionDetail(ArticleList):

    def get_queryset(self):
        self.region = get_object_or_404(models.Region, name=self.args[0])
        return models.Article.objects.list_view(). \
            filter(Q(region__in=self.region.get_descendants()) |
                   Q(region=self.region))

    def get_context_data(self, **kwargs):
        context = super(RegionDetail, self).get_context_data(**kwargs)
        query = Q(name=self.region.name)
        region_name = str(self.region)
        while region_name:
            region_name = region_name.rpartition("/")[0]
            query = query | Q(name=region_name)
        regions = models.Region.objects.filter(query)
        regions = ["<a href='" + reverse("newsroom:region.detail",
                                         args=(region.name, )) + "'>"
                   + region.name.rpartition("/")[2] + "</a>"
                   for region in regions]
        context['title'] = str(self.region).rpartition("/")[2]
        context['heading'] = "|".join(regions)
        return context


class TopicList(generic.ListView):
    model = models.Topic


class TopicDetail(ArticleList):

    def get_queryset(self):
        self.topic = get_object_or_404(models.Topic, slug=self.args[0])
        if self.topic.newest_first is True:
            return models.Article.objects.published(). \
                filter(topics=self.topic)
        else:
            return models.Article.objects.published(). \
                filter(topics=self.topic).order_by("published")

    def get_context_data(self, **kwargs):
        context = super(TopicDetail, self).get_context_data(**kwargs)
        context['heading'] = self.topic.name.upper()
        context['topic'] = self.topic
        return context

    def get_template_names(self):
        return (self.topic.template,)


# Support functions for article editing

def check_concurrent_edit(request):
    '''This is an Ajax callback on article update pages to
    check if another user has updated the article.
    '''
    if request.method == "POST" and \
       request.is_ajax and \
       request.user.has_perm("newsroom.change_article"):
        pk = int(request.POST["pk"])
        version = int(request.POST["version"])
        if request.POST["changed"] == "true":
            changed = True
        else:
            changed = False
        article = get_object_or_404(models.Article, pk=pk)
        if article.version > version:
            edited_by = str(article.user)
        else:
            edited_by = "(None)"
        try:
            user_edit = models.UserEdit.objects.get(
                article__pk=article.pk,
                user=request.user)
            user_edit.changed = changed
        except models.UserEdit.DoesNotExist:
            user_edit = models.UserEdit()
            user_edit.article = article
            user_edit.changed = changed
            user_edit.user = request.user
        finally:
            user_edit.save()
        cutoff = timezone.now() - datetime.timedelta(seconds=30)
        user_edits = models.UserEdit.objects. \
            filter(article=article). \
            exclude(user=request.user). \
            filter(edit_time__gte=cutoff)
        users = [obj.editStatusPlusName() for obj in user_edits]
        return JsonResponse({
            'edited_by': edited_by,
            'users': users
        }, safe=False)
    else:
        raise Http404


'''These functions were originally two generic Django class views (DetailView
and UpdateView). But the logic was hidden behind Django's opaque and not very
well documented system. This might seem complex with lots of coding that Django
could take care of, but at least I can understand what's going on here without
having to search reams of documentation and StackOverview questions.
Nevertheless, some refactoring needed here.

'''


def article_post(request, slug):
    form = ArticleForm(request.POST)
    if form.is_valid():
        if request.user.has_perm("newsroom.change_article"):
            article = get_object_or_404(models.Article, slug=slug)
            if article.version > form.cleaned_data["version"]:
                messages.add_message(request, messages.ERROR,
                                     utils.get_edit_lock_msg(article.user))
                for field in form.changed_data:
                    setattr(article, field,
                            form.cleaned_data[field])
                    return render(request, article.template,
                                  {'article': article,
                                   'display_region': None,
                                   'blocks': get_blocks('Article'),
                                   'can_edit': False,
                                   'article_letters': None,
                                   'most_popular_html': None,
                                   'form': form})
            for field in form.cleaned_data:
                setattr(article, field, form.cleaned_data[field])
            article.user = request.user
            article.save()
            # Check if user clicked "Publish" button
            if request.POST["is_published"] == "Now":
                article.publish_now()
                messages.add_message(request, messages.INFO,
                                     "Article published.")
            elif request.POST["input_top_story"] == "YES":
                article.make_top_story()
                messages.add_message(request, messages.INFO,
                                     "This is the top article.")
            elif request.POST["input_unsticky"] == "YES":
                messages.add_message(request, messages.INFO,
                                     "This article is no longer sticky.")
                article.unsticky()
            else:
                messages.add_message(request, messages.INFO,
                                     "Changes saved.")
            return HttpResponseRedirect(reverse('newsroom:article.detail',
                                                args=(slug,)))
        else:
            return HttpResponseForbidden()
    else:
        if form.data["title"] == "":
            messages.add_message(request, messages.ERROR,
                                 "Title can't be blank.")
        else:
            messages.add_message(request, messages.ERROR,
                                 "Something went wrong.")
        return HttpResponseRedirect(reverse('newsroom:article.detail',
                                            args=(slug,)))


def article_detail(request, slug):
    if request.method == 'POST':
        return article_post(request, slug)
    else:  # GET
        article = get_object_or_404(models.Article, slug=slug)
        if request.user.has_perm('newsroom.change_article'):
            form = ArticleForm(instance=article)
        else:
            form = None
        if article.is_published() or request.user.is_staff:
            if request.user.is_staff and not article.is_published():
                messages.add_message(request, messages.INFO,
                                     "This article is not published.")

            if article.region and (article.region.name not in
                                   ["None", "", "(None)", ]):
                display_region = article.region.name.rpartition("/")[2]
            else:
                display_region = ""

            can_edit = False
            if request.user.is_staff and \
               request.user.has_perm("newsroom.change_article"):
                can_edit = True
                query_edit = request.GET.get('edit', "true")
                if query_edit.lower() == "no" or \
                   query_edit.lower() == "false":
                    can_edit = False

            article_body = article.body
            if can_edit is False:
                try:
                    soup = BeautifulSoup(article_body, "html.parser")
                    soup = utils.processSupportUs(soup)
                    soup = utils.processAdverts(soup)
                    article_body = str(soup)
                except:
                    article_body = article_body.replace(
                        '<aside class="article-advert-edit">',
                        '<aside class="article-advert" style="display:none;">')
                    article_body = article_body.replace(
                        '<aside class="supportus-edit">',
                        '<aside class="supportus" style="display:none;">')

            date_from = timezone.now() - datetime.timedelta(days=DAYS_AGO)
            # most_popular = models.MostPopular.get_most_popular_html()
            return render(request, article.template,
                          {'article': article,
                           'display_region': display_region,
                           'recommended': article.get_recommended(),
                           'related': article.get_related(),
                           'blocks': get_blocks('Article'),
                           'can_edit': can_edit,
                           'article_body': article_body,
                           'article_letters': article.letter_set.published(),
                           'most_popular_html': models.MostPopular.get_most_popular_html(),
                           'letters': Letter.objects.published().
                           filter(published__gte=date_from).
                           order_by('-published'),
                           'content_type': 'article',
                           'form': form})
        else:
            raise Http404


def copy_article(request, slug):
    article = get_object_or_404(models.Article, slug=slug)
    if (article.is_published() or request.user.is_staff) and \
       article.encourage_republish:
        if request.user.is_staff and not article.is_published():
            messages.add_message(request, messages.INFO,
                                 "This article is not published.")
        return render(request, "newsroom/copy_article.html",
                      {'article': article})
    else:
        raise Http404


####################################################

''' Redirect images on old Drupal site
'''


class RedirectOldImages(View):

    def get(self, request, path):
        url = "/media/old/" + path
        return redirect(url)


'''Redirect hand constructed features (mainly an old site phenomenon

'''


class RedirectHandConstructedFeatures(View):

    def get(self, request, path):
        url = "/media/features/" + path
        return redirect(url)


'''Redirect old /content/ articles to new /article/

'''


class RedirectContentToArticle(View):

    def get(self, request, path):
        url = "/article/" + path
        return redirect(url)


'''newsletter generator form
'''


@staff_member_required
def generate_article_list(request):
    output = []
    articles = []
    if request.method == "POST":
        form = ArticleListForm(request.POST)
        if form.is_valid():
            date_from = form.cleaned_data["date_from"]
            date_to = form.cleaned_data["date_to"]
            if date_to:
                articles = models.Article.objects.published(). \
                    filter(published__gte=date_from). \
                    filter(published__lte=date_to)
            else:
                articles = models.Article.objects.published(). \
                    filter(published__gte=date_from)
            site_url = 'http://' + Site.objects.get_current().domain
            for article in articles:
                output.append("<h3><a href='" + site_url +
                              article.get_absolute_url() +
                              "'>" + article.title + "</a></h3>")
                output.append(
                    "<p>" + strip_tags(article.cached_summary_text) + "</p>")
                output.append("<p style='font-style:italic;'>" +
                              article.cached_byline_no_links + "</p>\n")
    else:
        form = ArticleListForm()

    return render(request, "newsroom/article_list_form.html",
                  {'form': form,
                   'output': output,
                   'len_articles': len(articles)})


def has_author(user):
    has_author = False
    try:
        has_author = (user.author is not None)
    except models.Author.DoesNotExist:
        pass
    return has_author


def account_profile(request):
    if request.user.is_authenticated is True:
        if has_author(request.user):
            if request.user.author.password_changed is False:
                messages.add_message(request, messages.WARNING,
                                     "Please change your password.")
    return render(request, "newsroom/account_profile.html")

def advanced_search(request):
    page = None
    query = request.GET.get('adv_search')
    search_type = request.GET.get('search_type')
    first_author = request.GET.get('first_author')
    first_author_only = True if first_author == "on" else False

    if request.GET.get('search_type') == 'article':
        inc_articles = True
        inc_photos = False
    else:
        inc_articles = True if search_type == 'article' or search_type == 'both' else False

    if request.GET.get('search_type') == 'image':
        inc_photos = True
        inc_articles = False
    else:
        inc_photos = True if search_type == 'image' or search_type == 'both' else False

    adv_search_form = AdvancedSearchForm(request.GET or None)

    if adv_search_form.is_valid():
        cleaned_adv_form = adv_search_form.cleaned_data
        author_pk = cleaned_adv_form.get("author").pk if cleaned_adv_form.get("author") else None
        category_pk = cleaned_adv_form.get("category").pk if cleaned_adv_form.get("category") else None
        topic_pk = cleaned_adv_form.get("topics").pk if cleaned_adv_form.get("topics") else None
        try:
            article_list = searchArticlesAndPhotos(cleaned_adv_form.get("adv_search"),
                                                   inc_articles,
                                                   inc_photos,
                                                   author_pk,
                                                   first_author_only,
                                                   category_pk,
                                                   topic_pk,
                                                   cleaned_adv_form.get("date_from"),
                                                   cleaned_adv_form.get("date_to"))
        except:
            logger.error("Advanced Search Failed calling searchArticlesAndPhotos")
            article_list = models.Article.objects.none()
    else:
        article_list = models.Article.objects.none()

    try:
        num_results = int(request.GET.get('results_per_page'))
    except:
        if search_type == 'image':
            num_results = settings.SEARCH_RESULTS_PER_PAGE * 2
        else:
            num_results = settings.SEARCH_RESULTS_PER_PAGE

    paginator = Paginator(article_list, num_results)
    page_num = request.GET.get('page')
    if page_num is None:
        page_num = 1
    try:
        page = paginator.page(page_num)
    except PageNotAnInteger:
        page = paginator.page(1)
    except EmptyPage:
        page = paginator.page(paginator.num_pages)
    except:
        logger.error("Advanced Search Failed in pagination")
    finally:
        try:
            num_pages = paginator.num_pages
        except:
            logger.error("Advanced Search failed to get num_pages")
            num_pages = 1


    return render(request, 'search/search.html', {'query': query,
                                                  'page': page,
                                                  'page_num': page_num,
                                                  'num_pages': num_pages,
                                                  'num_items': len(article_list),
                                                  'search_type': search_type,
                                                  'adv_search_form': adv_search_form})


''' Used to test logging
'''


def testLoggingDebug():
    logger.debug("Debug logging test")


def testLoggingInfo():
    logger.debug("Info logging test")


def testLoggingWarning():
    logger.debug("Warning logging test")


def testLoggingError():
    logger.error("Error logging test")


def testLoggingCritical():
    logger.critical("Critical logging test")


def testLoggingAll():
    testLoggingDebug()
    testLoggingInfo()
    testLoggingWarning()
    testLoggingError()
    testLoggingCritical()
